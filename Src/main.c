/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */


#include "main.h"

/* data declaration */

/* SPI handle for our SPI device */
spi_handle_t SpiHandle;

int TestReady = 0;\

/* slave will reply this data, when master issues read command */
uint8_t slave_reply_data[4]={ 0x55, 0xaa, 0x55, 0xaa};

/* master read/write buffers */
uint8_t master_write_data[]={ 0xa, 0xb, 0xc, 0xd };

uint8_t master_read_buffer[4];



int main(void)


{
	//uint32_t i=0;
	uint8_t addcm[CMD_LENGTH];
	uint8_t ack_buf[2];

	spi_gpio_init();


	led_init();  										// configure LED


	/* Configure USER Button as ext interrupt throw EXTI15 */

	_HAL_RCC_GPIOG_CLK_ENABLE();
	gpio_pin_conf_t gpio_pin_conf;
	gpio_pin_conf.pin = GPIO_BUTTON_PIN;
	gpio_pin_conf.mode = GPIO_PIN_INPUT_MODE;
	gpio_pin_conf.op_type = GPIO_PIN_OP_TYPE_PUSHPULL;
	gpio_pin_conf.pull = GPIO_PIN_NO_PULL_PUSH;
	gpio_pin_conf.speed = GPIO_PIN_SPEED_MEDIUM;
	hal_gpio_init(GPIO_BUTTON_PORT,&gpio_pin_conf);

	RCC->APB2ENR |= (1 << 14);
	SYSCFG->EXTICR[3] &= (0b1111 << 12);
	SYSCFG->EXTICR[3] |= (0b0110 << 12);
	hal_gpio_configure_interrupt(GPIO_BUTTON_PIN, INT_FALLING_EDGE);
	hal_gpio_enable_interrupt(GPIO_BUTTON_PIN, EXTI15_10_IRQn);

	_HAL_RCC_SPI2_CLK_ENABLE();


	/*fill up the SPI handle structure */
	SpiHandle.Instance				= SPI_2;

	SpiHandle.Init.BaudRatePrescaler = SPI_REG_CR1_BR_PCLK_DIV_32;
	SpiHandle.Init.Direction         = SPI_ENABLE_2_LINE_UNI_DIR;
	SpiHandle.Init.CLKPhase          = SPI_SECOND_CLOCK_TRANS;
	SpiHandle.Init.CLKPolarity       = SPI_CPOL_LOW;
	SpiHandle.Init.DataSize          = SPI_8BIT_DF_ENABLE;
	SpiHandle.Init.FirstBit          = SPI_MSB_FIRST;
	SpiHandle.Init.NSS               = SPI_SSM_ENABLE;
	SpiHandle.Init.Mode              = SPI_MASTER_MODE_SEL;

	SpiHandle.State = HAL_SPI_STATE_READY;

	/* Call driver API to initialize the SPI device */
	hal_spi_init(&SpiHandle);

	/* Enable the IRQs in the NVIC */
	NVIC_EnableIRQ(SPI2_IRQn);

	/* Wait for user Button press before starting the communication. Toggles LED_ORANGE until then */
	while (TestReady != SET) {
		led_toggle(GPIOI, LED_RED);
		//LED3 (orange)
		delay_gen();
	}
	hal_gpio_write_to_pin(GPIOI, LED_RED, 0);

	while (1) {
		//check for state ready
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* Master write command */
		addcm[0] = (uint8_t) CMD_MASTER_WRITE;
		addcm[1] = (uint8_t) ( CMD_MASTER_WRITE >> 8);

		/* first send the master write cmd to slave */
		hal_spi_master_tx(&SpiHandle, addcm, CMD_LENGTH);

		/* application can block here, or can do other task untill above tx finishes */
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* this dealy helps for the slave to be ready with the ACK bytes */
		delay_gen();

		/* read back the ACK bytes from the slave */
		hal_spi_master_rx(&SpiHandle, ack_buf, ACK_LEN);

		/* wait untill ACK reception finishes */
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* did we rcv the valid ACK from slave ?? */
		if (ack_buf[1] == 0XE5 && ack_buf[0] == 0xD5) {
			//correct ack
			led_toggle(GPIOC, LED_BLUE);
			memset(ack_buf, 0, 2);
		} else {
			//invalide ack
			assert_error();
			memset(ack_buf, 0, 2);
		}

		/* NOW send the data stream */
		hal_spi_master_tx(&SpiHandle, master_write_data, DATA_LENGTH);
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;
		delay_gen();

		//	read from slave

		/* Master READ command */
		addcm[0] = (uint8_t) CMD_MASTER_READ;
		addcm[1] = (uint8_t) ( CMD_MASTER_READ >> 8);

		/* first send the master write cmd to slave */
		hal_spi_master_tx(&SpiHandle, addcm, CMD_LENGTH);

		/* application can block here, or can do other task untill above tx finishes */
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* this dealy helps for the slave to be ready with the ACK bytes */
		delay_gen();

		/* read back the ACK bytes from the slave */
		hal_spi_master_rx(&SpiHandle, ack_buf, ACK_LEN);

		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		if (ack_buf[1] == 0XE5 && ack_buf[0] == 0xD5) {
			//correct ack
			led_toggle(GPIOC, LED_BLUE);
			memset(ack_buf, 0, 2); //what the hell??
		} else {
			//invalide ack
			assert_error();
			memset(ack_buf, 0, 2); //what the hell??
		}

		/* start receiving from the slave */
		hal_spi_master_rx(&SpiHandle, master_read_buffer, DATA_LENGTH);

		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* compare the data rcvd form slave, with what slave supposed to send */
		if (Buffercmp(master_read_buffer, slave_reply_data, DATA_LENGTH)) {
			// we didnt rcv what needs to be rcvd !!! Error !
			led_toggle(GPIOI, LED_RED);
		} else {
			//Rcvd correct data
			led_toggle(GPIOC, LED_BLUE);
		}

		delay_gen();
	}
}


void delay_gen(void) {
	uint32_t cnt = 800000;
	while (cnt--)
		;
}

void led_init(void){
	gpio_pin_conf_t gpio_pin_conf;

	_HAL_RCC_GPIOI_CLK_ENABLE();
	gpio_pin_conf.pin = LED_RED;
	gpio_pin_conf.mode = GPIO_PIN_OUTPUT_MODE;
	gpio_pin_conf.op_type = GPIO_PIN_OP_TYPE_PUSHPULL;
	gpio_pin_conf.pull = GPIO_PIN_NO_PULL_PUSH;
	gpio_pin_conf.speed = GPIO_PIN_SPEED_MEDIUM;
	hal_gpio_init(GPIOI,&gpio_pin_conf);

	_HAL_RCC_GPIOC_CLK_ENABLE();
	gpio_pin_conf.pin = LED_BLUE;
	hal_gpio_init(GPIOC, &gpio_pin_conf);

}

void led_toggle(GPIO_TypeDef *GPIOx, uint16_t pin) {
	if (hal_gpio_read_from_pin(GPIOx, pin))
		hal_gpio_write_to_pin(GPIOx, pin, 0);
	else
		hal_gpio_write_to_pin(GPIOx, pin, 1);
}

void spi_gpio_init(void){
	gpio_pin_conf_t gpio_pin_conf;

	_HAL_RCC_GPIOI_CLK_ENABLE();

	/* configure GPIOI_PIN_1 for SPI CLK functionality */
	gpio_pin_conf.pin = SPI_CLK_PIN;
	gpio_pin_conf.mode = GPIO_PIN_ALT_FUN_MODE;
	gpio_pin_conf.op_type = GPIO_PIN_OP_TYPE_PUSHPULL;
	gpio_pin_conf.pull = GPIO_PIN_PUSH_DOWN;
	gpio_pin_conf.speed = GPIO_PIN_SPEED_MEDIUM;

	hal_gpio_set_alt_function(GPIOI, SPI_CLK_PIN, GPIO_PIN_AF5_SPI2);
	hal_gpio_init(GPIOI,&gpio_pin_conf);

	/* configure GPIOI_PIN_2 for SPI MISO functionality */
	gpio_pin_conf.pin = SPI_MISO_PIN;
	gpio_pin_conf.pull = GPIO_PIN_PULL_UP;

	hal_gpio_set_alt_function(GPIOI, SPI_MISO_PIN, GPIO_PIN_AF5_SPI2);
	hal_gpio_init(GPIOI, &gpio_pin_conf);

	/* configure GPIOI_PIN_3 for SPI MISO functionality */
	gpio_pin_conf.pin = SPI_MOSI_PIN;
	gpio_pin_conf.pull = GPIO_PIN_PULL_UP;

	hal_gpio_set_alt_function(GPIOI, SPI_MOSI_PIN, GPIO_PIN_AF5_SPI2);
	hal_gpio_init(GPIOI, &gpio_pin_conf);
}

void assert_error(void) {
	while (1) {
		led_toggle(GPIOI, LED_RED);
		delay_gen();
	}
}

static uint16_t Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
{
  while (BufferLength--)
  {
    if((*pBuffer1) != *pBuffer2)
    {
      return BufferLength;
    }
    pBuffer1++;
    pBuffer2++;
  }
	return 0;
}

/*
 * @brief  brief  This function handles EXTI15-10 interrupt request.
 * @param  none
 * @retval none
 */
void EXTI15_10_IRQHandler(void){
	hal_gpio_clear_interrupt(GPIO_BUTTON_PIN);
	TestReady = SET;
}

/*
 * @brief  This function handles SPI2 interrupt request.
 * @param  none
 * @retval none
 */
void SPI2_IRQHandler(void) {
	/* call the driver api to process this interrupt */
	hal_spi_irq_handler(&SpiHandle);
}




