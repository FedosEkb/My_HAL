/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */


#include "main.h"

/* data declaration */

/* SPI handle for our SPI device */
spi_handle_t SpiHandle;

i2c_handle_t i2c_handle;

int TestReady = 0;

/* slave will reply this data, when master issues read command */
uint8_t slave_reply_data[4]={ 0x55, 0xaa, 0x55, 0xaa};

/* master read/write buffers */
uint8_t master_write_data[]={ 0xa, 0xb, 0xc, 0xd };

uint8_t master_read_buffer[4];



int main(void)


{
	//uint32_t i=0;

#ifdef SPI_TEST
	uint8_t addcm[CMD_LENGTH];
	uint8_t ack_buf[2];

#endif

	spi_gpio_init();
	i2c_gpio_init();
	led_init();					// configure LED

	button_init();				/* Configure USER Button as ext interrupt throw EXTI15 */

	/**
	 ******************************************************************************
	 	 	 	 	 	 	 	 		SPI CONFIG
	 ******************************************************************************
	  */

	_HAL_RCC_SPI2_CLK_ENABLE();

	/*fill up the SPI handle structure */
	SpiHandle.Instance = SPI_2;

	SpiHandle.Init.BaudRatePrescaler = SPI_REG_CR1_BR_PCLK_DIV_32;
	SpiHandle.Init.Direction         = SPI_ENABLE_2_LINE_UNI_DIR;
	SpiHandle.Init.CLKPhase          = SPI_SECOND_CLOCK_TRANS;
	SpiHandle.Init.CLKPolarity       = SPI_CPOL_LOW;
	SpiHandle.Init.DataSize          = SPI_8BIT_DF_ENABLE;
	SpiHandle.Init.FirstBit          = SPI_MSB_FIRST;
	SpiHandle.Init.NSS               = SPI_SSM_ENABLE;
	SpiHandle.Init.Mode              = SPI_MASTER_MODE_SEL;

	SpiHandle.State = HAL_SPI_STATE_READY;

	/* Call driver API to initialize the SPI device */
	hal_spi_init(&SpiHandle);

	/* Enable the IRQs in the NVIC */
	NVIC_EnableIRQ(SPI2_IRQn);
	/**
	 ******************************************************************************
	 	 	 	 	 	 	 	 	 I2C CONFIG
	 ******************************************************************************
	 */
	_HAL_RCC_I2C2_CLK_ENABLE();
	i2c_handle.Instance = I2C_2;        // base address in memory
	i2c_handle.Init.ack_enable = I2C_ACK_ENABLE;
	i2c_handle.Init.AddressingMode = I2C_ADDRMODE_7BIT;
	i2c_handle.Init.ClockSpeed = 100000;
	i2c_handle.Init.DutyCycle = I2C_FM_DUTY_2; //care needs to taken
	i2c_handle.Init.GeneralCallMode = 0;
	i2c_handle.Init.NoStretchMode = I2C_ENABLE_CLK_STRETCH;
	i2c_handle.Init.OwnAddress1 = SLAVE_OWN_ADDRESS;

	NVIC_EnableIRQ(I2Cx_ER_IRQn);
	NVIC_EnableIRQ(I2Cx_EV_IRQn);

	hal_i2c_init(&i2c_handle);
	hal_i2c_enable_peripheral(i2c_handle.Instance);  // It need for something. I think 2IC enable occur in TX/RX function

	//hal_gpio_enable_interrupt(0);

	//val = i2c_handle.Instance->CR1;
	i2c_handle.State = HAL_I2C_STATE_READY;
	/******************************************************************************/



	/* Wait for user Button press before starting the communication. Toggles LED_ORANGE until then */
	while (TestReady != SET) {
		led_toggle(GPIOI, LED_RED);
		//LED3 (orange)
		delay_gen();
	}
	hal_gpio_write_to_pin(GPIOI, LED_RED, 0);

	while (1) {
#ifdef I2C_TEST
		while (i2c_handle.State != HAL_I2C_STATE_READY)
			;
#ifdef I2C_MASTER_MODE_EN // code for MASTER implementation

		/*						Write to the slave						*/

		/* first send the master write cmd to slave */
		master_write_req = MASTER_WRITE_CMD;
		hal_i2c_master_tx(&i2c_handle, SLAVE_ADDRESS_WRITE,
				(uint8_t*) &master_write_req, 1);
		while (i2c_handle.State != HAL_I2C_STATE_READY)
			; // application can block here, or you can put here some useful task

		master_write_req = WRITE_LEN;
		/* Now send the number of bytes to be written */
		hal_i2c_master_tx(&i2c_handle, SLAVE_ADDRESS_WRITE,
				(uint8_t*) &master_write_req, 1);

		while (i2c_handle.State != HAL_I2C_STATE_READY)
			; // application can block here, or you can put here some useful task

		/* NOW send the data stream */
		hal_i2c_master_tx(&i2c_handle, SLAVE_ADDRESS_WRITE, master_tx_buffer,
				WRITE_LEN);

		while (i2c_handle.State != HAL_I2C_STATE_READY)
			; // application can block here, or you can put here some useful task

		/*						Read from the slave						*/


		/* first send the master read cmd to slave */
		master_read_req = MASTER_READ_CMD;
		hal_i2c_master_tx(&i2c_handle, SLAVE_ADDRESS_WRITE,
				(uint8_t*) &master_read_req, 1);
		while (i2c_handle.State != HAL_I2C_STATE_READY)
			; // application can block here, or you can put here some useful task

		master_read_req = READ_LEN;
		/* Now send the number of bytes to be read */
		hal_i2c_master_tx(&i2c_handle, SLAVE_ADDRESS_WRITE,
				(uint8_t*) &master_read_req, 1);

		while (i2c_handle.State != HAL_I2C_STATE_READY)
			; // application can block here, or you can put here some useful task

		memset(master_rx_buffer, 0, 5); // reset RX buffer
		/* NOW read the data stream */
		hal_i2c_master_rx(&i2c_handle, SLAVE_ADDRESS_READ, master_rx_buffer,
				READ_LEN);
		while (i2c_handle.State != HAL_I2C_STATE_READY)
			; // application can block here, or you can put here some useful task

		if (Buffercmp(slave_tx_buffer, master_rx_buffer, READ_LEN)) {
			hal_gpio_write_to_pin(GPIOI, LED_RED, 1);
		} else
			led_toggle(GPIOC, LED_BLUE);


		delay_gen();

#else   // code for SLAVE implementation
		/* first rcv the command from the master */
		hal_i2c_slave_rx(&i2c_handle, &slave_rcv_cmd, 1);
		while (i2c_handle.State != HAL_I2C_STATE_READY)
			;

		if (slave_rcv_cmd == MASTER_WRITE_CMD) {
			//prepare to rcv from the master
			//first rcv no bytes to be written by master
			hal_i2c_slave_rx(&i2c_handle, &slave_rcv_cmd, 1);
			while (i2c_handle.State != HAL_I2C_STATE_READY)
				;
			memset(slave_rx_buffer, 0, sizeof(slave_rx_buffer));
			hal_i2c_slave_rx(&i2c_handle, slave_rx_buffer, slave_rcv_cmd);
			while (i2c_handle.State != HAL_I2C_STATE_READY)
				;

			if (Buffercmp(slave_rx_buffer, master_tx_buffer, READ_LEN)) {
				hal_gpio_write_to_pin(GPIOI, LED_RED, 1);
			} else
				led_toggle(GPIOC, LED_BLUE);
		}

		if (slave_rcv_cmd == MASTER_READ_CMD) {
			//prepare to send data to the  master
			//first rcv no bytes to be written to master
			hal_i2c_slave_rx(&i2c_handle, &slave_rcv_cmd, 1);
			while (i2c_handle.State != HAL_I2C_STATE_READY)
				;

			hal_i2c_slave_tx(&i2c_handle, slave_tx_buffer, slave_rcv_cmd);
			while (i2c_handle.State != HAL_I2C_STATE_READY)
				;

		}

#endif  //	end master/slave choice
#endif  //	end I2C test scenario
#ifdef SPI_TEST
		//check for state ready
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* Master write command */
		addcm[0] = (uint8_t) CMD_MASTER_WRITE;
		addcm[1] = (uint8_t) ( CMD_MASTER_WRITE >> 8);

		/* first send the master write cmd to slave */
		hal_spi_master_tx(&SpiHandle, addcm, CMD_LENGTH);

		/* application can block here, or can do other task untill above tx finishes */
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* this dealy helps for the slave to be ready with the ACK bytes */
		delay_gen();

		/* read back the ACK bytes from the slave */
		hal_spi_master_rx(&SpiHandle, ack_buf, ACK_LEN);

		/* wait untill ACK reception finishes */
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* did we rcv the valid ACK from slave ?? */
		if (ack_buf[1] == 0XE5 && ack_buf[0] == 0xD5) {
			//correct ack
			led_toggle(GPIOC, LED_BLUE);
			memset(ack_buf, 0, 2);
		} else {
			//invalide ack
			assert_error();
			memset(ack_buf, 0, 2);
		}

		/* NOW send the data stream */
		hal_spi_master_tx(&SpiHandle, master_write_data, DATA_LENGTH);
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;
		delay_gen();

		//	read from slave

		/* Master READ command */
		addcm[0] = (uint8_t) CMD_MASTER_READ;
		addcm[1] = (uint8_t) ( CMD_MASTER_READ >> 8);

		/* first send the master write cmd to slave */
		hal_spi_master_tx(&SpiHandle, addcm, CMD_LENGTH);

		/* application can block here, or can do other task untill above tx finishes */
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* this dealy helps for the slave to be ready with the ACK bytes */
		delay_gen();

		/* read back the ACK bytes from the slave */
		hal_spi_master_rx(&SpiHandle, ack_buf, ACK_LEN);

		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		if (ack_buf[1] == 0XE5 && ack_buf[0] == 0xD5) {
			//correct ack
			led_toggle(GPIOC, LED_BLUE);
			memset(ack_buf, 0, 2); //what the hell??
		} else {
			//invalide ack
			assert_error();
			memset(ack_buf, 0, 2); //what the hell??
		}

		/* start receiving from the slave */
		hal_spi_master_rx(&SpiHandle, master_read_buffer, DATA_LENGTH);

		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* compare the data rcvd form slave, with what slave supposed to send */
		if (Buffercmp(master_read_buffer, slave_reply_data, DATA_LENGTH)) {
			// we didnt rcv what needs to be rcvd !!! Error !
			led_toggle(GPIOI, LED_RED);
		} else {
			//Rcvd correct data
			led_toggle(GPIOC, LED_BLUE);
		}

		delay_gen();
#endif
	}
}


void delay_gen(void) {
	uint32_t cnt = 800000;
	while (cnt--)
		;
}

void i2c_gpio_init(void) {
	gpio_pin_conf_t i2c_pin;

	_HAL_RCC_GPIOB_CLK_ENABLE();

	i2c_pin.pin = I2C1_SCL_LINE;
	i2c_pin.mode = GPIO_PIN_ALT_FUN_MODE;
	i2c_pin.op_type = GPIO_PIN_OP_TYPE_OPENDRAIN;
	i2c_pin.pull = GPIO_PIN_PULL_UP;
	i2c_pin.speed = GPIO_PIN_SPEED_HIGH;

	hal_gpio_set_alt_function(GPIOB, I2C1_SCL_LINE, GPIO_PIN_AF4_I2C123);
	hal_gpio_init(GPIOB, &i2c_pin);

	i2c_pin.pin = I2C1_SDA_LINE;	// need change only pin number another have got same configuration

	hal_gpio_set_alt_function(GPIOB, I2C1_SDA_LINE, GPIO_PIN_AF4_I2C123);
	hal_gpio_init(GPIOB, &i2c_pin);
}


void led_init(void){
	gpio_pin_conf_t gpio_pin_conf;

	_HAL_RCC_GPIOI_CLK_ENABLE();
	gpio_pin_conf.pin = LED_RED;
	gpio_pin_conf.mode = GPIO_PIN_OUTPUT_MODE;
	gpio_pin_conf.op_type = GPIO_PIN_OP_TYPE_PUSHPULL;
	gpio_pin_conf.pull = GPIO_PIN_NO_PULL_PUSH;
	gpio_pin_conf.speed = GPIO_PIN_SPEED_MEDIUM;
	hal_gpio_init(GPIOI,&gpio_pin_conf);

	_HAL_RCC_GPIOC_CLK_ENABLE();
	gpio_pin_conf.pin = LED_BLUE;
	hal_gpio_init(GPIOC, &gpio_pin_conf);

}

void led_toggle(GPIO_TypeDef *GPIOx, uint16_t pin) {
	if (hal_gpio_read_from_pin(GPIOx, pin))
		hal_gpio_write_to_pin(GPIOx, pin, 0);
	else
		hal_gpio_write_to_pin(GPIOx, pin, 1);
}

void spi_gpio_init(void){
	gpio_pin_conf_t gpio_pin_conf;

	_HAL_RCC_GPIOI_CLK_ENABLE();

	/* configure GPIOI_PIN_1 for SPI CLK functionality */
	gpio_pin_conf.pin = SPI_CLK_PIN;
	gpio_pin_conf.mode = GPIO_PIN_ALT_FUN_MODE;
	gpio_pin_conf.op_type = GPIO_PIN_OP_TYPE_PUSHPULL;
	gpio_pin_conf.pull = GPIO_PIN_PUSH_DOWN;
	gpio_pin_conf.speed = GPIO_PIN_SPEED_MEDIUM;

	hal_gpio_set_alt_function(GPIOI, SPI_CLK_PIN, GPIO_PIN_AF5_SPI2);
	hal_gpio_init(GPIOI,&gpio_pin_conf);

	/* configure GPIOI_PIN_2 for SPI MISO functionality */
	gpio_pin_conf.pin = SPI_MISO_PIN;
	gpio_pin_conf.pull = GPIO_PIN_PULL_UP;

	hal_gpio_set_alt_function(GPIOI, SPI_MISO_PIN, GPIO_PIN_AF5_SPI2);
	hal_gpio_init(GPIOI, &gpio_pin_conf);

	/* configure GPIOI_PIN_3 for SPI MISO functionality */
	gpio_pin_conf.pin = SPI_MOSI_PIN;
	gpio_pin_conf.pull = GPIO_PIN_PULL_UP;

	hal_gpio_set_alt_function(GPIOI, SPI_MOSI_PIN, GPIO_PIN_AF5_SPI2);
	hal_gpio_init(GPIOI, &gpio_pin_conf);
}

void assert_error(void) {
	while (1) {
		led_toggle(GPIOI, LED_RED);
		delay_gen();
	}
}

void button_init(void) {
	_HAL_RCC_GPIOG_CLK_ENABLE();

	gpio_pin_conf_t gpio_pin_conf;
	gpio_pin_conf.pin = GPIO_BUTTON_PIN;
	gpio_pin_conf.mode = GPIO_PIN_INPUT_MODE;
	gpio_pin_conf.op_type = GPIO_PIN_OP_TYPE_PUSHPULL;
	gpio_pin_conf.pull = GPIO_PIN_NO_PULL_PUSH;
	gpio_pin_conf.speed = GPIO_PIN_SPEED_MEDIUM;
	hal_gpio_init(GPIO_BUTTON_PORT, &gpio_pin_conf);

	RCC->APB2ENR |= (1 << 14);
	SYSCFG->EXTICR[3] &= (0b1111 << 12);
	SYSCFG->EXTICR[3] |= (0b0110 << 12);
	hal_gpio_configure_interrupt(GPIO_BUTTON_PIN, INT_FALLING_EDGE);
	hal_gpio_enable_interrupt(GPIO_BUTTON_PIN, EXTI15_10_IRQn);
}

static uint16_t Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
{
  while (BufferLength--)
  {
    if((*pBuffer1) != *pBuffer2)
    {
      return BufferLength;
    }
    pBuffer1++;
    pBuffer2++;
  }
	return 0;
}

/*
 * @brief  brief  This function handles EXTI15-10 interrupt request.
 * @param  none
 * @retval none
 */
void EXTI15_10_IRQHandler(void){
	hal_gpio_clear_interrupt(GPIO_BUTTON_PIN);
	TestReady = SET;
}


/*
 * @brief  This function handles I2C event interrupt request.
 * @param  none
 * @retval none
 */
void I2C2_EV_IRQHandler(void){
	HAL_I2C_EV_IRQHandler(& i2c_handle);
}


/*
 * @brief  This function handles I2C error interrupt request.
 * @param  none
 * @retval none
 */
void I2C2_ER_IRQHandler(void){
	HAL_I2C_ER_IRQHandler(& i2c_handle);
}


/*
 * @brief  This function handles SPI2 interrupt request.
 * @param  none
 * @retval none
 */
void SPI2_IRQHandler(void) {
	hal_spi_irq_handler(&SpiHandle);	/* call the driver api to process this interrupt (thanks cap!=))*/
}




